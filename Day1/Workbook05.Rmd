---
title: "Workbook"
author: "Model Evaluation"
date: "`r Sys.Date()`"
output:
  html_document:
    # css: docs/src/styles/styles.css
    number_sections: true
    theme: united
    toc: true
    toc_float: true
params:
  include: TRUE
---


```{r,echo=FALSE,message=FALSE}
knitr::opts_chunk$set(comment='.',fig.align=TRUE,message=FALSE,warning=FALSE)
```


# Preliminaries for R examples

```{r, message=FALSE}
library(tidyverse)
library(stringr)
library(haven)
library(GGally)
library(binom)
library(texreg)
library(mgcv)
library(DHARMa)

expit <- function(x) 1 / (1+exp(-x))
```

```{r, purl=TRUE, results = "hide"}
# Preamble of data assembly and model fitting done in previous workbooks

load('../data/aedat.RDS')
aedat <-
  aedat %>% group_by(USUBJID) %>%
  # End of study for patients without a severe event
  mutate(TTE_SEVERE = case_when(
    STUDYID=="PROTA" ~ 2,
    STUDYID=="PROTB" ~ 6
  ),
  # Time of severe event for those that had one
  TTE_SEVERE = ifelse(AETOXGR=="Severe", TTE, TTE_SEVERE)
  )
dat_use <-
  aedat %>% arrange(USUBJID, TTE_SEVERE) %>% slice(1) %>%
  group_by(PBO) %>%
  mutate(Quartile = ifelse(PBO == "PBO", "PBO",
                           paste0("Q", ntile(CAVGSS, n = 4))))
dat_mod <- dat_use
mod01 <- glm(AE01 ~ CAVGSS + PTTYPE,
             family = binomial(link = "logit"),
             data = dat_mod,
             )
ref_bwt <- median(dat_use$BWT) # will want reference value later, so save as variable!
dat_mod <- dat_use %>% mutate(
  BWT_norm = BWT - ref_bwt,
  PTTYPE = factor(PTTYPE, levels = c("PT1", "PT2", "HV"))
  )
mod03 <- glm(AE01 ~ CAVGSS + PTTYPE + BWT_norm,
             family = binomial(link = "logit"),
             data = dat_mod,
             )
```


# Workbook: Model evaluation and comparison


## Residual plot


```{r, "TRY resid", purl=TRUE, results = "hide"}
dat_plus <- dat_mod
dat_plus$res <- residuals(mod01, type = "response")
dat_plus$pred <- fitted(mod01)

resplot <-
  ggplot(dat_plus, aes(x = CAVGSS, y = res)) +
  geom_point() +
  geom_smooth()

resplot  
resplot + facet_wrap(~ PTTYPE)

# deviance residuals
dat_plus$resd <- residuals(mod01, type = "deviance")
dat_plus$pred <- fitted(mod01)

resplot <-
  ggplot(dat_plus, aes(x = CAVGSS, y = resd)) +
  geom_point() +
  geom_smooth()

resplot  
resplot + facet_wrap(~ PTTYPE)

```

Suggestive of:

* Over-predicting rates for HV at high exposures.
* Possibly underpredicting at mid-range exposures for `PT1`.

Exercise: Plot residuals by `BWT`, faceting by `STUDYID`.

```{r}

```


Exercise:

Binned residuals are another way to smooth out the discreteness in binary residuals.
The general algorithm is to:

1. Bin the data by fitted value
2. Within each bin, calculate the average
    * residual
    * fitted probability of the outcome
    * continuous covariate values
3. Plot the average residual (y axis) against the other average metrics per bin
4. Include thresholds for the residuals at +/- 2*sqrt(p_bin(1-p_bin)/n_bin), where p_bin is
    is the fitted probability

```{r}

```

## Pred v. conc

```{r, "TRY predconc", purl=TRUE, results = "hide"}
p <- ggplot(dat_plus, aes(x = CAVGSS)) +
  geom_rug(data = filter(dat_plus, AE01 == 0),
           sides = "b") +
  geom_rug(data = filter(dat_plus, AE01 == 1),
           sides = "t") +
  # NB: default smoother is problematic for 0-1
  # data. More on this later but live with it
  # for now.
  geom_smooth(aes(y = AE01))

p
p + geom_line(aes(y = pred))
p + geom_line(aes(y = pred)) + facet_wrap(~PTTYPE)
```

Exercise: make a version of the previous plot that smooths out the predicted values.

```{r}

```

# DHARMa residuals


```{r}

simulationOutput = DHARMa::simulateResiduals(mod01, n = 1000)
plot(simulationOutput)
DHARMa::plotResiduals(simulationOutput)
DHARMa::plotResiduals(simulationOutput,form=dat_mod$CAVGSS,xlab="CAVE")

```

## VPC vs a categorical covariate

```{r, "TRY glmvpc", purl=TRUE, results = "hide"}
prop <- function(x) sum(x, na.rm = TRUE) / sum(!is.na(x))
obs_stat <-
  dat_mod %>%
  group_by(PTTYPE, Quartile) %>%
  summarise(pAE = prop(AE01))
ggplot(obs_stat) +
  geom_point(aes(x = Quartile, y = pAE)) +
  facet_wrap(~ PTTYPE)
```

```{r, "TRY2 glmvpc", purl=TRUE, results = "hide"}
# nobs x nsim matrix of simulated values
sim_dat <- stats::simulate(mod03, 100) # running this "quick and dirty", but could easily bump reps to 1000

# Function to calculate predicted prob of event per PTTYPE and quartile
stat_fn <- function(simy, dat_orig = dat_mod) {
  dati <- dat_orig
  dati$AE01 <- simy
  dati %>%
    group_by(PTTYPE, Quartile) %>%
    summarise(pAE = prop(AE01))
}

sim_stat <- apply(sim_dat, 2, stat_fn) %>% bind_rows()

sim_stat_q <-
  sim_stat %>%
  group_by(PTTYPE,Quartile) %>%
  summarize(LB=quantile(pAE, prob=c(0.05)),
            MED=median(pAE),
            UB=quantile(pAE, prob=.95)
  )

comb_stat <- full_join(obs_stat, sim_stat_q)

ggplot(data = comb_stat) +
  geom_pointrange(aes(x = Quartile, y = MED, ymin = LB, ymax = UB, colour = "Predicted")) +
  geom_point(aes(x = Quartile, y = pAE, colour = "Observed"), size = 3, alpha = 0.5) +
  facet_wrap(~ PTTYPE) + theme_bw()
```

Exercise: Create a VPC for the proportion of patients with an AE within each gender.

```{r}

```

## VPC against continuous predictors

```{r, "TRY continvpc", purl=TRUE, results = "hide"}
obs_stat <-
  dat_mod %>%
  ungroup %>%
  mutate(pAE=predict(loess(AE01 ~ CAVGSS, data = dat_mod))) %>%
  group_by(CAVGSS) %>%
  summarize(pAE=mean(pAE)) # Could use distinct, should be identical

stat_fn <- function(simy, dat_orig = dat_mod) {
  dati <- dat_orig
  dati$AE01 <- simy
  dati$pAE <- predict(loess(AE01 ~ CAVGSS, data = dati))
  dati %>% group_by(CAVGSS) %>% summarize(pAE=mean(pAE))
}

sim_stat <-
  data.frame(sim_dat) %>%
  select_all() %>%
  map(~stat_fn(.)) %>%
  bind_rows

sim_stat_q <-
  sim_stat %>%
  group_by(CAVGSS) %>%
  summarize(LB=quantile(pAE, prob=c(0.05)),
            MED=median(pAE),
            UB=quantile(pAE, prob=.95)
  )

comb_stat <- full_join(obs_stat, sim_stat_q)

ggplot(data = comb_stat) +
  geom_ribbon(aes(x = CAVGSS, ymin = LB, ymax = UB, colour = "Predicted"), fill = "lightgrey") +
  geom_line(aes(x = CAVGSS, y = MED, colour = "Predicted"), size = 3) +
  geom_line(aes(x = CAVGSS, y = pAE, colour = "Observed"), size = 3) +
  theme_bw()
```

Exercise: Make a similar VPC plotted against bodyweight.

```{r}

```


Exercise: Our model includes an interaction term, make a VPC of CAVGSS by PTTYPE

```{r}

```


Extended Exercise:

* Re-fit the first model (mod01) to allow a different slope of exposure-response relationship for each level of `PTTYPE`. 
(Hint: the formula will be AE01 ~ CAVGSS*PTTYPE)
* Re-generate the residual and pred v. conc plots and compare the results.
* Read `?aic` and compare the models with and without interaction in terms of AIC.

```{r}

```


```{r, "TRY lincombo", purl=TRUE, results = "hide"}
lin_combo <- function(fit, k.lin) {
  est <- coef(fit) %*% k.lin  
  V <- t(k.lin) %*% vcov(fit) %*% k.lin
  se <- sqrt(V)
  out <- c(est, se)
  out
}
names(coef(mod03))
which.pars <- names(coef(mod03)) %in% c("CAVGSS", "CAVGSS:PTTYPEHV")
as.numeric(which.pars)
lin_combo(mod03, as.numeric(which.pars))
```

Compare the above result with what you get when you re-fit the model with `HV` as the reference level.

```{r}

```



## Conditional predictions

```{r, "TRY forest", purl=TRUE, results = "hide"}
# We need some reference exposure levels:
ref_exp <- 1:3
# and some reference bodyweights:
ref_bwt_norm <- c(65, 75, 85) - ref_bwt
# For categorical covariates it is more straightforward:
ref_sex <- unique(dat_mod$SEXTXT)
ref_type <- unique(dat_mod$PTTYPE)
# Now let's make a grid of setting where we want predictions:
pred_frame <- expand.grid(BWT_norm = ref_bwt_norm,
                          CAVGSS = ref_exp,
                          SEXTXT = ref_sex,
                          PTTYPE = ref_type
                          )

pred_frame$Pred <- predict(mod03, newdata = pred_frame)
pred_frame$PredSE <- predict(mod03, newdata = pred_frame, se.fit = TRUE)$se.fit
pred_frame <- pred_frame %>%
  mutate(
    LB = 100 * expit(Pred + qnorm(0.025) * PredSE),
    EST = 100 * expit(Pred),
    UB = 100 * expit(Pred + qnorm(0.975) * PredSE)
  )
pred_frame$BWT <- round(pred_frame$BWT_norm + ref_bwt, 0)
pred_frame$Label = with(pred_frame, paste(PTTYPE, SEXTXT, BWT, CAVGSS))

pred_frame

ggplot(data = filter(pred_frame, PTTYPE != "HV")) +
  geom_pointrange(aes(x=Label, y=EST, ymin=LB, ymax=UB)) +
  coord_flip() + facet_wrap(~PTTYPE, scales="free_y") +
  xlab("Estimated AE Rate")

ggplot(data = filter(pred_frame, PTTYPE != "HV")) +
  geom_pointrange(aes(x=Label, y=EST, ymin=LB, ymax=UB)) +
  coord_flip() + facet_wrap(~SEXTXT, scales="free_y") +
  xlab("Estimated AE Rate")

```

Exercise: Re-fit the model without any covariate-exposure interactions and re-make the "forest plot" of conditional predictions.

```{r}

```


## Marginal predictions

When making marginal predictions, we wish to describe an average (marginal) effect over some population.

Let's compare marginal predictions of CAVGSS for PT1 and PT2 like those studied:

```{r, "TRY marginal-cavg-pttype", purl=TRUE}
pt1pats <- filter(dat_mod, PTTYPE=="PT1") %>%
  sample_n(10000,replace=TRUE) %>%
  select(CAVGSS,PTTYPE,BWT_norm,SEXTXT)

pt2pats <- filter(dat_mod, PTTYPE=="PT2") %>%
  sample_n(10000,replace=TRUE) %>%
  select(CAVGSS,PTTYPE,BWT_norm,SEXTXT)

pt1pats %>% ungroup %>% summary
pt2pats %>% ungroup %>% summary

CAVGSS_at <- seq(min(dat_mod$CAVGSS[dat_mod$CAVGSS>0]),
                 max(dat_mod$CAVGSS), length.out = 50)

pats <- bind_rows(pt1pats,pt2pats)%>% ungroup
pats$CAVGSS <- NULL

pred_eff <-
  map_df(seq_along(CAVGSS_at), function(CAVGSS_i){
    pats %>%
      mutate(CAVGSS=CAVGSS_at[CAVGSS_i]) %>%
      mutate(
        xb=predict(mod03, newdata=., type="link")
      ) %>%
      group_by(CAVGSS,PTTYPE) %>%
      summarize(pAE=expit(mean(xb)),
                ul=expit(mean(xb)+2*sd(xb)),
                ll=expit(mean(xb)-2*sd(xb)))
  })

pred_eff %>%
  ggplot(aes(x=CAVGSS, y=pAE, color=PTTYPE, fill=PTTYPE, ymax=ul, ymin=ll)) +
  geom_line() + theme_bw() +
  geom_ribbon(alpha=.25) +
  ggtitle("Marginal effect")
```

Exercise:
Suppose that exposure varies with bodyweight, plot the net effect across studied weights.

```{r}

```


## Clinical trial simulation

There is a planned Ph2 study in 100 PT2 patients.  
The patients will be dosed with a target CAVGSS of 2.5, and we expect values to fall
between 2.25 and 2.75 (say it varies normally around 2.5).  

* What rate of serious AE's should we expect in this trial?
* Compare with and without parameter uncertainty

Hint:
? MASS::mvrnorm
? model.matrix
? model.frame

```{r}
```


## Get your GAM on

```{r}
?s
mod04 <- gam(AE01 ~ s(CAVGSS,by=PTTYPE) + PTTYPE + BWT_norm + SEXTXT,
             data=dat_mod, family = "binomial")
```

```{r, "TRY marginal-cavg-pttype-gam", purl=TRUE}
pt1pats <- filter(dat_mod, PTTYPE=="PT1") %>%
  ungroup() %>%
  sample_n(10000,replace=TRUE) %>%
  select(CAVGSS,PTTYPE,BWT_norm,SEXTXT)

pt2pats <- filter(dat_mod, PTTYPE=="PT2") %>%
  ungroup() %>%
  sample_n(10000,replace=TRUE) %>%
  select(CAVGSS,PTTYPE,BWT_norm,SEXTXT)

pt1pats %>% ungroup %>% summary
pt2pats %>% ungroup %>% summary

CAVGSS_at <- seq(min(dat_mod$CAVGSS[dat_mod$CAVGSS>0]),
                 max(dat_mod$CAVGSS), length.out = 50)

pats <- bind_rows(pt1pats,pt2pats)%>% ungroup
pats$CAVGSS <- NULL

pred_eff <-
  map_df(seq_along(CAVGSS_at), function(CAVGSS_i){
    pats %>%
      mutate(CAVGSS=CAVGSS_at[CAVGSS_i])  %>%
      mutate( xb=predict(mod04, newdata=., type="link") ) %>%
      group_by(CAVGSS,PTTYPE) %>%
      summarize(mxb=mean(xb), sxb=sd(xb)) %>%
      mutate(pAE = expit(mxb), ul=expit(mxb+2*sxb), ll=expit(mxb-2*sxb))
  })

pred_eff %>%
  ggplot(aes(x=CAVGSS, y=pAE, color=PTTYPE, fill=PTTYPE,ymax=ul, ymin=ll)) +
  geom_line(lwd=2) + theme_bw() +
  geom_ribbon(alpha=.25) +
  ggtitle("Marginal effect")
```